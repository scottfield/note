##显示锁(ReentrantLock)与内置锁(synchronized)的比较
两种加锁方式都能实现同样的内存语义，并且对共享数据提供独占式的访问而且同时支持重入。
###synchronized
####优点:
- 语法简单，不易出错，众人皆知，只需要在方法声明或者代码块儿上添加synchronized关键字即可
- 不需要手动的获取和释放锁，完全有JVM自动完成
- 可以很容易的通过threadump来定位死锁发生的位置
- JVM能够进行一些锁的自动优化来提升性能，例如锁消除优化，

####缺点：
- 不支持锁获取过程的中断
- 无法设置锁的超时时间
- 无法进行轮询式的锁获取方式
- 不支持锁的公平性选择
- 性能比显示锁要稍差一些，但是在1.6以后区别不是很大
- 只能在一个方法内进行锁定



###ReentrantLock
####优点:
- 可以对获取锁的过程进行定时，方便实现对操作时间有限制的需求
- 可以中断锁的获取，可以实现有取消功能的需求
- 可以已轮询的方式来获取锁，可以实现对在获取锁失败的情况下，需要做其它备选处理的需求
- 可以选择使用公平锁还是非公平锁（默认为非公平锁）
- 可以实现跨方法的锁定
- 
- 性能更优异，并且可以使用连锁式加锁的方式来实现分段加锁，以进一步降低锁的粒度获取更好的性能
####缺点：
- 语法复杂，一般以try-finally的方式来手动的获取和释放，可能由于疏忽从而造成死锁
- 出现死锁后不能通过threaddump来诊断，比较难于发现

###如何判断是选择公平锁还是非公平锁？
如果锁的持有时间非常短暂，而且竞争比较激烈的情况下，使用非公平锁可以带来更多的性能提升，因为在排队线程被唤醒期间，活跃线程对锁进行请求也可以立即获取到锁.
否则就改使用公平锁来防止线程饥饿问题的发生。而且大多数情况下，非公平锁的性能是优于公平锁的，这也是为什么Java默认使用非公平锁。

###读写锁(ReadWriteLock)
读和写线程分别使用不同的锁来对共享数据进行加锁，允许多个读线程同时获取读锁来访问共享数据，而只能允许一个写线程获取写锁对数据进行修改。
比较适合在读多写少的情况下使用来提升性能，如果是写比较多的情况下，性能反倒因为复杂度的提高还不如排他锁。

###Lock的Condition和Object自带条件队列的比较


###为什么轮询的tryLock会造成公平锁的插队问题？
###如何避免死锁？
- 通过使用相同顺序来获取锁从而避免死锁的发生
- 使用显示锁的轮询和定时功能来避免死锁的发生