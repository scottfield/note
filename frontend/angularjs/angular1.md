### scopes
- the scopes are hierarchies parallel with DOM scopes
- use $watch API to observe model mutations,watch type are Watching by reference,Watching collection contents and Watching by value
- use $apply API to propagate model changes through angular from outside of "Angular Realm"
- all scopes are marked with class name ng-scope,
    in Chrome dev tool,we can get the scope content by 
```
angular.element($0).scope()
```
### Scope Events Propagation
- $broadcast propagate to child scopes
- $emit propagate to parent scopes

### Scope Lifecycle
- Creation

The root scope is created during the application bootstrap by the $injector. During template linking, some directives create new child scopes.

- Watcher registration

During template linking, directives register watches on the scope. These watches will be used to propagate model values to the DOM.

- Model mutation

For mutations to be properly observed, you should make them only within the scope.$apply(). Angular APIs do this implicitly, so no extra $apply call is needed when doing synchronous work in controllers, or asynchronous work with $http, $timeout or $interval services.

- Mutation observation

At the end of $apply, Angular performs a $digest cycle on the root scope, which then propagates throughout all child scopes. During the $digest cycle, all $watched expressions or functions are checked for model mutation and if a mutation is detected, the $watch listener is called.

- Scope destruction

When child scopes are no longer needed, it is the responsibility of the child scope creator to destroy them via scope.$destroy() API. This will stop propagation of $digest calls into the child scope and allow for memory used by the child scope models to be reclaimed by the garbage collector.
### Controller
Use controllers to:
- Set up the initial state of the $scope object.
- Add behavior to the $scope object.
### Service
Angular services are:

- Lazily instantiated – Angular only instantiates a service when an application component depends on it.
- Singletons – Each component dependent on a service gets a reference to the single instance generated by the service factory.